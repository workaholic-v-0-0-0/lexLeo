// src/parser/bison/parser.y.in

/* @formatter:off */
%define parse.error verbose
%define parse.trace
%define api.pure full

%lex-param   { yyscan_t scanner }

%parse-param { yyscan_t scanner }
%parse-param { ast **result }
%parse-param { struct parser_ctx *ctx }

%code requires {
    #include "parser_types.h"
    struct parser_ctx;

    // forward declaration
    typedef void* yyscan_t;
    void *yyget_extra(yyscan_t scanner);
}

%{
    #include <stdlib.h>
    #include <stdio.h>
    #include <string.h>
    #include "ast.h"
    #include "parser_ctx.h"
%}

%code provides {
    int yyerror(yyscan_t scanner, ast **result, struct parser_ctx *ctx, const char *s);
    int yylex(YYSTYPE *yylval, yyscan_t scanner);
}

%union {
    int int_value;
    char *string_value;
    char *symbol_name_value;
ast *ast;
}
%destructor { free($$); } <string_value> <symbol_name_value>

@TERMINAL_LEXEMS_DECLARATION@

%left ADD SUBTRACT
%left MULTIPLY DIVIDE
%right UMINUS

%type <ast> @NON_TERMINAL_LEXEMS_LIST@
%destructor { if ($$) ctx->ops.destroy($$); } <ast>

%token TU_MODE
%token ONE_STATEMENT_MODE
%token READABLE_MODE

%start start

%%

start
    : TU_MODE translation_unit END {
        if (ctx->goal != PARSE_GOAL_TU) YYERROR;
        *result = $2;
    }
    | ONE_STATEMENT_MODE statement {
        if (ctx->goal != PARSE_GOAL_ONE_STATEMENT) YYERROR;
        *result = $2;
        YYACCEPT;
    }
    | ONE_STATEMENT_MODE END {
        if (ctx->goal != PARSE_GOAL_ONE_STATEMENT) YYERROR;
        *result = NULL;
        YYACCEPT;
    }
    | READABLE_MODE readable END {
        if (ctx->goal != PARSE_GOAL_READABLE) YYERROR;
        *result = $2;
        YYACCEPT;
    }
    ;

readable
    : evaluable {$$ = $1;}
    | block {$$ = $1;}
    ;

@GRAMMAR_RULES@

%%

int yyerror(yyscan_t scanner, ast **result, struct parser_ctx *ctx, const char *msg) {
    (void)result;
    if (!((lexer_extra_t*) yyget_extra(scanner))->reached_input_end) ctx->syntax_errors++;
    fprintf(stderr, "Parse error: %s\n", msg);
    return 1;
}

/* @formatter:on */

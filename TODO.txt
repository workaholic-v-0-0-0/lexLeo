- Document all existing modules, functions, and code structure using Doxygen comments

- Refactor CMake structure to make sub-projects standalone

- lexer TDD

- TDD for eval_rule
- TDD for writing_rule
- TDD for symbol_rule

- runtime_env: distinguish UNBOUND vs OOM and update interpreter to propagate precise errors

- refact src/core/interpreter/tests
  - note:
    - param_case is constant but its ctx field points on a non constant struct
    - for each expected value, there must be a field in param_case and a field
      with the same name in ctx ; then during arrange stage, the information
      is propagated
    - a lot of pattern mistake has been done ; for example, doubles for values
      fetched in environment (which is doubled too in a dummy fashion) must be
      handled through ctx

- except since parser implementation,
  the unit tests of the modules
  below the parser layer are poorly written and need to be
  redone, mainly because they test implementation details
  instead of observable behavior, choose the wrong unit of
  testing, and misuse mocks, fakes, or stubs. To avoid the
  same mistakes again, here is a reminder of the standard
  test-double terminology:
    - dummy: not used by the CUT, only fills a parameter slot required by the signature
    - stub: used by the CUT (even if only passed on to a mock inside the test), but does not behave like the real dependency; it typically returns fixed values or minimal responses
    - fake: used by the CUT and simulates the real dependency’s behavior, but with simplified internal details (e.g. in-memory DB instead of a real DB)
    - mock: used by the CUT; what is simulated is the interaction between the CUT and the dependency, and those interactions are configured in the test during the arrange phase
    - spy: a special kind of stub that records the interactions between the CUT and the dependency, so the test can verify them afterwards during the assert phase
    - test double: umbrella term for any of the above
  and:
    - do not double passive data structures that the CUT is supposed to mutate; use real instances so you can assert on the resulting state. (use fakes/mocks for external collaborators with behavior.)
    - prefer spies over mocks when call ordering is not part of the contract, to keep tests resilient to refactoring. use mocks with explicit expectations when order and exact interactions are part of the protocol.
      (for example, when creating a symbol, strdup is called after malloc for symbol in the first implementation and it's hard
       to refactor by reversing the two calls to avoid a call to free)
  remember: a unit test can also be an integration test, and the only so-called
    “unit tests” that are not integration tests are those that merely lock down
    implementation details instead of observable behavior.

- unit tests for hashtable with key type is void*

- unit tests for the actions of LHS computable rules

- complete unit tests for the actions of the following rules:
  - statement: function_definition
  - statement: function_call SEMICOLON

- refact grammar with:
  - rename binding with assignment

- Refactor interpreter/CLI:
  - Add an output stream field to interpreter_ctx, used by AST_TYPE_WRITING for output

- fix ast_destroy so that it destroys AST of type AST_TYPE_ERROR

- Shift the responsibility for detecting duplicate parameter names in function definitions from interpreter_eval to the resolver
  (name/scope phase). This enforces the rule early and keeps the interpreter focused on runtime concerns only.

- make tests for stream module

- Implement a small-buffer optimization for argument evaluation (stack array for small
  arities, heap allocation for larger arities) and remove the hard fixed AST_MAX_ARITY
  limitation from the interpreter hot path.

- Add resolver-level validation to detect function definitions and function calls whose
  arity exceeds the maximum supported limit (AST_MAX_ARITY), and report
  RESOLVER_ERROR_MAX_ARITY_OVERFLOW before interpreter execution.

- tests for arguments and list_of_arguments

- Handle TYPE_ERROR during computable evaluation (e.g. "string * symbol" now possible
  after arguments migration)

- fix bug so that get lookups in parents scopes

- Add a stream abstract factory to input_provider ctx
  (for stream creation/destruction, no switch)
- Add a stream_stack to input_provider (push/pop active streams)

- complete doc: explain lexleo_assert is for invariant, explain lexleo_panic too

- suppress string_utils, memory_allocators

- Add Flex buffer-state stack for import/include directives
  Support `import "file.leo"` as a lexer-level directive (no AST node) by using
  Flex buffer-state stacking. This enables safe switching of input sources
  (REPL chunks ↔ file ↔ chunks) despite Flex internal buffering.
  - Keep the existing `input_provider_legacy_read()` contract unchanged.
  - Extend input_provider with source stack operations (`push_file`, `pop_source`).
  - lexleo_flex handles `import` by pushing/popping:
    - Flex buffer states (`yypush_buffer_state` / `yypop_buffer_state`)
    - input_provider sources.
  - On EOF of an imported file, restore the previous source transparently.
  Out of scope:
  - No AST `import` node.
  - No module / namespace system (source inclusion only).


- typo in lexleo_flex diagram: flex_next-> next

- must runtime_session be lexleo_vm?

- dbs:
  - integration test
  - unit test for factory

- handle different build type with regard to test

- make fs_stream properly
- make logger module properly and adjust osal, stream and dbs
- make osal module properly
- complete doc with diagrams

- adjust unit_test_dynamic_buffer_stream.c (it's put on off)

- Refactor module layout

- Clarify wiring headers visibility (BUILD_INTERFACE vs install)

- update doc pages into standards/

- explain Mechanism of a non-port module for providing creators in
  docs/manual/architecture/module_taxonomy.md


<here> continue cleanup doc ; arrange project tree ; see message (how to suppress tree pages on the left side bar?)

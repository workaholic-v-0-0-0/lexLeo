- Document all existing modules, functions, and code structure using Doxygen comments

- Refactor CMake structure to make sub-projects standalone

- lexer TDD

- check if there's a memory leak due to strdup in lexer

- except for parser, resolver, runtime_env and interpreter,
  the unit tests of the modules
  below the parser layer are poorly written and need to be
  redone, mainly because they test implementation details
  instead of observable behavior, choose the wrong unit of
  testing, and misuse mocks, fakes, or stubs. To avoid the
  same mistakes again, here is a reminder of the standard
  test-double terminology:
    - dummy: not used by the CUT, only fills a parameter slot required by the signature
    - stub: used by the CUT (even if only passed on to a mock inside the test), but does not behave like the real dependency; it typically returns fixed values or minimal responses
    - fake: used by the CUT and simulates the real dependency’s behavior, but with simplified internal details (e.g. in-memory DB instead of a real DB)
    - mock: used by the CUT; what is simulated is the interaction between the CUT and the dependency, and those interactions are configured in the test during the arrange phase
    - spy: a special kind of stub that records the interactions between the CUT and the dependency, so the test can verify them afterwards during the assert phase
    - test double: umbrella term for any of the above
  and:
    - do not double passive data structures that the CUT is supposed to mutate; use real instances so you can assert on the resulting state. (use fakes/mocks for external collaborators with behavior.)
    - prefer spies over mocks when call ordering is not part of the contract, to keep tests resilient to refactoring. use mocks with explicit expectations when order and exact interactions are part of the protocol.
      (for example, when creating a symbol, strdup is called after malloc for symbol in the first implementation and it's hard
       to refactor by reversing the two calls to avoid a call to free)
  remember: a unit test can also be an integration test, and the only so-called
    “unit tests” that are not integration tests are those that merely lock down
    implementation details instead of observable behavior.

- unit tests for hashtable with key type is void*

- unit tests for the actions of LHS computable rules

- complete unit tests for the actions of the following rules:
  - statement: function_definition
  - statement: function_call SEMICOLON

- refact grammar with:
  - rename binding with assignment

- fix memory leaks caused by the list module

- continue to TDD interpreter_eval with the following order:
  - AST_TYPE_READING
  - AST_TYPE_BINDING
  - AST_TYPE_WRITING
  - AST_TYPE_BLOCK_ITEMS
  - AST_TYPE_BLOCK
  - AST_TYPE_TRANSLATION_UNIT
  - AST_TYPE_FUNCTION_CALL

- fix ast_destroy so that it destroys AST of type AST_TYPE_ERROR

- Make symtab_intern_symbol() idempotent. It should succeed even if the symbol already exists in the table — only fail on OOM or internal inconsistency.
  Goal:
  Avoid incorrect “intern failed” errors when the same symbol name (e.g., duplicate parameter or repeated identifier) appears multiple times in the same or nested scopes.
  Subsequent occurrences of an already-interned name must simply retrieve and reuse the existing symbol* entry instead of returning an error.

- Shift the responsibility for detecting duplicate parameter names in function definitions from interpreter_eval to the resolver
  (name/scope phase). This enforces the rule early and keeps the interpreter focused on runtime concerns only.

- make AST_TYPE_READING evaluable by the interpreter:
  - "make 2 starts in parser.h":
     - keep current start for whole files:
       - translation_unit (parses until EOF)
       - add a start that parses exactly one statement (returns as soon as one full statement is reduced)
  - make a module input_provider
  - make a module read_engine
  - make a module runtime_session with:
      typedef bool (*resolve_ast_fn_t)(struct ast **a, struct resolver_ctx ctx);
      typedef struct runtime_session {
          list ast_pool;
          list symbol_pool;
          input_provider in;
          symtab *st;
          resolve_ast_fn_t resolve_ast_fn;
          struct resolver_ctx resolver_ctx;
      } runtime_session;
      but don't write "struct runtime_session runtime_session;" to avoid collision
  - in runtime_env, migrate to frames that reference the runtime_session:
      typedef struct runtime_env {
          hashtable *bindings; // key: const symbol* (borrowed), value: runtime_env_value (refcounted)
          size_t refcount;
          bool is_root;
          struct runtime_env *parent;
          runtime_session *session;
      } runtime_env;
  - replace the static global symbol_pool:
    - one symbol_pool per session (owned by runtime_session, or internally by symtab).

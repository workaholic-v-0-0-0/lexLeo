- Document all existing modules, functions, and code structure using Doxygen comments

- Refactor CMake structure to make sub-projects standalone

- lexer TDD

- check if there's a memory leak due to strdup in lexer

- except for parser, resolver, runtime_env and interpreter,
  the unit tests of the modules
  below the parser layer are poorly written and need to be
  redone, mainly because they test implementation details
  instead of observable behavior, choose the wrong unit of
  testing, and misuse mocks, fakes, or stubs. To avoid the
  same mistakes again, here is a reminder of the standard
  test-double terminology:
    - dummy: not used by the CUT, only fills a parameter slot required by the signature
    - stub: used by the CUT (even if only passed on to a mock inside the test), but does not behave like the real dependency; it typically returns fixed values or minimal responses
    - fake: used by the CUT and simulates the real dependency’s behavior, but with simplified internal details (e.g. in-memory DB instead of a real DB)
    - mock: used by the CUT; what is simulated is the interaction between the CUT and the dependency, and those interactions are configured in the test during the arrange phase
    - spy: a special kind of stub that records the interactions between the CUT and the dependency, so the test can verify them afterwards during the assert phase
    - test double: umbrella term for any of the above
  and:
    - do not double passive data structures that the CUT is supposed to mutate; use real instances so you can assert on the resulting state. (use fakes/mocks for external collaborators with behavior.)
    - prefer spies over mocks when call ordering is not part of the contract, to keep tests resilient to refactoring. use mocks with explicit expectations when order and exact interactions are part of the protocol.
      (for example, when creating a symbol, strdup is called after malloc for symbol in the first implementation and it's hard
       to refactor by reversing the two calls to avoid a call to free)
  remember: a unit test can also be an integration test, and the only so-called
    “unit tests” that are not integration tests are those that merely lock down
    implementation details instead of observable behavior.

- unit tests for hashtable with key type is void*

- unit tests for the actions of LHS computable rules

- complete unit tests for the actions of the following rules:
  - statement: function_definition
  - statement: function_call SEMICOLON

- refact grammar with:
  - rename binding with assignment

- fix memory leaks caused by the list module

- continue to TDD interpreter_eval with the following order:
  - AST_TYPE_QUOTE
  - AST_TYPE_READING
  - AST_TYPE_BINDING
  - AST_TYPE_WRITING
  - AST_TYPE_BLOCK_ITEMS
  - AST_TYPE_BLOCK
  - AST_TYPE_TRANSLATION_UNIT
  - AST_TYPE_FUNCTION_CALL

- make interpreter_eval error when child of function_definition node
  is not a function_node and fix some eventual mistakes of
  the same kind ;
  in order to do that, implement constructors of invalid ASTs

- fix ast_destroy so that it destroys AST of type AST_TYPE_ERROR

- Make symtab_intern_symbol() idempotent. It should succeed even if the symbol already exists in the table — only fail on OOM or internal inconsistency.
  Goal:
  Avoid incorrect “intern failed” errors when the same symbol name (e.g., duplicate parameter or repeated identifier) appears multiple times in the same or nested scopes.
  Subsequent occurrences of an already-interned name must simply retrieve and reuse the existing symbol* entry instead of returning an error.

- Shift the responsibility for detecting duplicate parameter names in function definitions from interpreter_eval to the resolver
  (name/scope phase). This enforces the rule early and keeps the interpreter focused on runtime concerns only.

- changes:
  - interpreter_eval:
      - when evaluating a symbol data wrapper AST (except in LHS assignment or "function contexts"),
        resolve the symbol to its associated runtime value in the current or an ancestor environment.
      - ensure proper fallback behavior when the symbol is unbound (return INTERPRETER_STATUS_UNBOUND_SYMBOL or equivalent)
  - grammar:
      - update the "computable" rule to accept generic atoms, not only numeric ones
        (e.g., allow expressions like "atom_number + atom_symbol" or "atom + atom").
  - interpreter:
      - add runtime type checking for computation nodes
      - use INTERPRETER_STATUS_TYPE_ERROR to report invalid operand types
      - ensure quoted expressions are not evaluated within computations

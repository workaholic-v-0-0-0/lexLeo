- Document all existing modules, functions, and code structure using Doxygen comments

- Refactor CMake structure to make sub-projects standalone

- lexer TDD

- check if there's a memory leak due to strdup in lexer

- except for the parser’s and the resolver's, the unit tests of the modules
  below the parser layer are poorly written and need to be
  redone, mainly because they test implementation details
  instead of observable behavior, choose the wrong unit of
  testing, and misuse mocks, fakes, or stubs. To avoid the
  same mistakes again, here is a reminder of the standard
  test-double terminology:
    - dummy: not used by the CUT, only fills a parameter slot required by the signature
    - stub: used by the CUT (even if only passed on to a mock inside the test), but does not behave like the real dependency; it typically returns fixed values or minimal responses
    - fake: used by the CUT and simulates the real dependency’s behavior, but with simplified internal details (e.g. in-memory DB instead of a real DB)
    - mock: used by the CUT; what is simulated is the interaction between the CUT and the dependency, and those interactions are configured in the test during the arrange phase
    - spy: a special kind of stub that records the interactions between the CUT and the dependency, so the test can verify them afterwards during the assert phase
    - test double: umbrella term for any of the above
  and:
    - do not double passive data structures that the CUT is supposed to mutate; use real instances so you can assert on the resulting state. (use fakes/mocks for external collaborators with behavior.)
    - prefer spies over mocks when call ordering is not part of the contract, to keep tests resilient to refactoring. use mocks with explicit expectations when order and exact interactions are part of the protocol.
      (for example, when creating a symbol, strdup is called after malloc for symbol in the first implementation and it's hard
       to refactor by reversing the two calls to avoid a call to free)
  remember: a unit test can also be an integration test, and the only so-called
    “unit tests” that are not integration tests are those that merely lock down
    implementation details instead of observable behavior.

- scopes and closures handling:
  - in ast: add the following types:
      - AST_TYPE_FUNCTION
      - AST_TYPE_FUNCTION_DEFINITION
      - AST_TYPE_LIST_OF_PARAMETERS
      - AST_TYPE_BLOC
  - in parser: add grammar rules which actions are to build
    the AST of the previous types.
  - in resolver: modify resolver so that it winds a new scope to resolve
    symbol which are parameters of a function

- make a new module interpreter_environment:
  - a stack of hashtable with a ref_nb to retain/release
    the interpreter values (interpreter_value)
    - it will stored symbol*->interpreter_value associations
  - while unwinding of a closure:
    - the structure of the closure won't be freed if its
      ref_nb is greater than 0
    - the interpreter values of the closure can have a
      ref_nb too ; they are freed only if it's greater
      than 0
    - the keys type is symbol* so they are not freed
      (see later)
  - this is different from the resolution environment which:
    - store char*->symbol* associations
    - own its keys (?)
    - always free the structure of the closure while unwinding
      and never frees its borrowed symbol* values (see later)

- modifies/clarifies memory ownerships:
  - symbol*: owned by the global symbol_pool
  - interpreter_value: owned by? a retain/release mecanism?

- unit tests for hashtable with key type is void*


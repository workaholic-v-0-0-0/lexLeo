- Document all existing modules, functions, and code structure using Doxygen comments

- Refactor CMake structure to make sub-projects standalone

- lexer TDD

- TDD for eval_rule
- TDD for writing_rule

- runtime_env: distinguish UNBOUND vs OOM and update interpreter to propagate precise errors

- refact src/interpreter/tests
  - note:
    - param_case is constant but its ctx field points on a non constant struct
    - for each expected value, there must be a field in param_case and a field
      with the same name in ctx ; then during arrange stage, the information
      is propagated
    - a lot of pattern mistake has been done ; for example, doubles for values
      fetched in environment (which is doubled too in a dummy fashion) must be
      handled through ctx

- except since parser implementation,
  the unit tests of the modules
  below the parser layer are poorly written and need to be
  redone, mainly because they test implementation details
  instead of observable behavior, choose the wrong unit of
  testing, and misuse mocks, fakes, or stubs. To avoid the
  same mistakes again, here is a reminder of the standard
  test-double terminology:
    - dummy: not used by the CUT, only fills a parameter slot required by the signature
    - stub: used by the CUT (even if only passed on to a mock inside the test), but does not behave like the real dependency; it typically returns fixed values or minimal responses
    - fake: used by the CUT and simulates the real dependency’s behavior, but with simplified internal details (e.g. in-memory DB instead of a real DB)
    - mock: used by the CUT; what is simulated is the interaction between the CUT and the dependency, and those interactions are configured in the test during the arrange phase
    - spy: a special kind of stub that records the interactions between the CUT and the dependency, so the test can verify them afterwards during the assert phase
    - test double: umbrella term for any of the above
  and:
    - do not double passive data structures that the CUT is supposed to mutate; use real instances so you can assert on the resulting state. (use fakes/mocks for external collaborators with behavior.)
    - prefer spies over mocks when call ordering is not part of the contract, to keep tests resilient to refactoring. use mocks with explicit expectations when order and exact interactions are part of the protocol.
      (for example, when creating a symbol, strdup is called after malloc for symbol in the first implementation and it's hard
       to refactor by reversing the two calls to avoid a call to free)
  remember: a unit test can also be an integration test, and the only so-called
    “unit tests” that are not integration tests are those that merely lock down
    implementation details instead of observable behavior.

- unit tests for hashtable with key type is void*

- unit tests for the actions of LHS computable rules

- complete unit tests for the actions of the following rules:
  - statement: function_definition
  - statement: function_call SEMICOLON

- refact grammar with:
  - rename binding with assignment

- Refactor interpreter/CLI:
  - Add an output stream field to interpreter_ctx, used by AST_TYPE_WRITING for output

- continue to TDD interpreter_eval with the following order:
  - AST_TYPE_FUNCTION_CALL

- fix ast_destroy so that it destroys AST of type AST_TYPE_ERROR

- Shift the responsibility for detecting duplicate parameter names in function definitions from interpreter_eval to the resolver
  (name/scope phase). This enforces the rule early and keeps the interpreter focused on runtime concerns only.

- make tests for stream module
